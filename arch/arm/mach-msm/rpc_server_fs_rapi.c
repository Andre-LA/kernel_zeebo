/* arch/arm/mach-msm/rpc_server_fs_rapi.c
 *
 * Copyright (C) 2012 Triple Oxygen
 *
 * This software is licensed under the terms of the GNU General Public
 * License version 2, as published by the Free Software Foundation, and
 * may be copied, distributed, and modified under those terms.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 */

#include <linux/module.h>
#include <linux/kernel.h>
#include <mach/msm_rpcrouter.h>
#include <mach/msm_smd.h>
#include <linux/slab.h>

#define FS_RAPI_PROG 				0x30000011
#define	FS_RAPI_VERS				0
#define RPC_FS_RAPI_NULL_PROC			0
#define RPC_FS_RAPI_MOUNT_PROC			1
#define RPC_FS_RAPI_GETSTAT_VFS_PROC		2
#define RPC_FS_RAPI_GETSTAT_PROC		3
#define RPC_FS_RAPI_LOOKUP_PROC			4
#define RPC_FS_RAPI_CREATE_PROC			5
#define RPC_FS_RAPI_READ_PROC			6
#define RPC_FS_RAPI_WRITE_PROC			7
#define RPC_FS_RAPI_MKDIR_PROC			8
#define RPC_FS_RAPI_RMDIR_PROC			9
#define RPC_FS_RAPI_UNLINK_PROC			10
#define RPC_FS_RAPI_RENAME_PROC			11
#define RPC_FS_RAPI_TRUNCATE_PROC		12
#define RPC_FS_RAPI_SYMLINK_PROC		13
#define RPC_FS_RAPI_READLINK_PROC		14
#define RPC_FS_RAPI_READDIR_PROC		15
#define RPC_FS_RAPI_CLOSEDIR_PROC		16
#define RPC_FS_RAPI_MKNOD_PROC			17
#define RPC_FS_RAPI_CHMOD_PROC			18
#define RPC_FS_RAPI_CHOWN_PROC			19

struct fs_rapi_hdr {
	uint32_t one;
	uint32_t zero;
	uint32_t two;
	uint32_t zero2;
	uint32_t one2;
};

struct fs_rapi_write_req {
	struct fs_rapi_hdr hdr;
	uint32_t node_id;
	uint32_t offset;
	uint32_t size;
	/* data, padded to multiple of 4 */
	uint32_t size2;
	uint32_t one3;
};

struct fs_rapi_write_rpl {
	uint32_t written_size;
	uint32_t one;
	uint32_t zero;
	uint32_t node_id;
	uint32_t unk;
	uint32_t one2;
	uint32_t written_size2;
	uint32_t unk2;
	uint32_t one3;
	uint32_t zero2;
	uint64_t timestamp;
	uint32_t zeros[3];
};

struct fs_rapi_read_req {
	struct fs_rapi_hdr hdr;
	uint32_t node_id;
	uint32_t ftr[5];
};

struct fs_rapi_read_rpl {
	uint32_t two;
	uint32_t size;
	/* data, padded to multiple of 4 */
	uint32_t one;
	uint32_t zero;
	uint32_t node_id;
	//uint32_t unk[];
};

struct rpc_fs_rapi_mount_args {
	uint32_t unk0;
	uint32_t unk1;
	uint32_t unk2;
	uint32_t unk3;
};

struct rpc_fs_rapi_lookup_args_hdr {
	uint32_t unk0;
	uint32_t unk1;
	uint32_t unk2;
	uint32_t unk3;
	uint32_t unk4;
	uint32_t unk5;
	uint32_t size;
};

struct rpc_fs_rapi_open_args_ftr {
	uint32_t unk0;
	uint32_t unk1;
	uint32_t unk2;
};

struct rpc_fs_rapi_api_params {
	unsigned req_size;
	char *name;
};

static struct rpc_fs_rapi_api_params rpc_fs_rapi_apis[] = {
	[RPC_FS_RAPI_NULL_PROC] = { .req_size = 0, .name = "FS_RAPI_NULL" },
	[RPC_FS_RAPI_MOUNT_PROC] = { .req_size = 0, .name = "FS_RAPI_MOUNT" },
	[RPC_FS_RAPI_GETSTAT_VFS_PROC] = { .req_size = 0, .name = "FS_RAPI_GETSTAT_VFS" },
	[RPC_FS_RAPI_GETSTAT_PROC] = { .req_size = 0, .name = "FS_RAPI_GETSTAT" },
	[RPC_FS_RAPI_LOOKUP_PROC] = { .req_size = 0, .name = "FS_RAPI_LOOKUP" },
	[RPC_FS_RAPI_CREATE_PROC] = { .req_size = 0, .name = "FS_RAPI_CREATE" },
	[RPC_FS_RAPI_READ_PROC] = { .req_size = 0, .name = "FS_RAPI_READ" },
	[RPC_FS_RAPI_WRITE_PROC] = { .req_size = 0, .name = "FS_RAPI_WRITE" },
	[RPC_FS_RAPI_MKDIR_PROC] = { .req_size = 0, .name = "FS_RAPI_MKDIR" },
	[RPC_FS_RAPI_RMDIR_PROC] = { .req_size = 0, .name = "FS_RAPI_RMDIR" },
	[RPC_FS_RAPI_UNLINK_PROC] = { .req_size = 0, .name = "FS_RAPI_UNLINK" },
	[RPC_FS_RAPI_RENAME_PROC] = { .req_size = 0, .name = "FS_RAPI_RENAME" },
	[RPC_FS_RAPI_TRUNCATE_PROC] = { .req_size = 0, .name = "FS_RAPI_TRUNCATE" },
	[RPC_FS_RAPI_SYMLINK_PROC] = { .req_size = 0, .name = "FS_RAPI_SYMLINK" },
	[RPC_FS_RAPI_READLINK_PROC] = { .req_size = 0, .name = "FS_RAPI_READLINK" },
	[RPC_FS_RAPI_READDIR_PROC] = { .req_size = 0, .name = "FS_RAPI_READDIR" },
	[RPC_FS_RAPI_CLOSEDIR_PROC] = { .req_size = 0, .name = "FS_RAPI_CLOSEDIR" },
	[RPC_FS_RAPI_MKNOD_PROC] = { .req_size = 0, .name = "FS_RAPI_MKNOD" },
	[RPC_FS_RAPI_CHMOD_PROC] = { .req_size = 0, .name = "FS_RAPI_CHMOD" },
	[RPC_FS_RAPI_CHOWN_PROC] = { .req_size = 0, .name = "FS_RAPI_CHOWN" },
}; 

uint8_t reply_mount[] = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
	0x00, 0x00, 0x00, 0x60
};

/* lookup request from AMSS
 * 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
 * 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00,
 * 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x60,
 * 0x00, 0x00, 0x00, 0x11, 0x55, 0x69, 0x6d, 0x45,
 * 0x66, 0x73, 0x41, 0x50, 0x44, 0x55, 0x4c, 0x6f,
 * 0x67, 0x2e, 0x54, 0x78, 0x74, 0x00, 0x00, 0x00,
 * 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x01,
 * 0x00, 0x00, 0x00, 0x01,
 *
 * lookup "err" (dir?)
 * 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
 * 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00,
 * 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x60,
 * 0x00, 0x00, 0x00, 0x03, 0x65, 0x72, 0x72, 0x00,
 * 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x01,
 * 0x00, 0x00, 0x00, 0x01,
 *
 * reply to lookup "err"
 * 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
 * 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,
 * 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
 * 0x00, 0x01, 0x8f, 0x80, 0x00, 0x00, 0x00, 0x01,
 * 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x8f, 0x80,
 * 0x00, 0x00, 0x41, 0xed, 0x00, 0x00, 0x00, 0x02,
 * 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 0x08, 0x00,
 * 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 * 0x12, 0xd5, 0x3d, 0x80, 0x12, 0xd5, 0x3d, 0x80,
 * 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 * 0x00, 0x00, 0x00, 0x00, 
 */

uint8_t reply_lookup[] = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,
	0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
	0x00, 0x00, 0x00, 0x73, 0x00, 0x00, 0x00, 0x01,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x73,
	0x00, 0x00, 0x81, 0x80, 0x00, 0x00, 0x00, 0x01,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	//0x12, 0xd5, 0x3d, 0x80, 0x12, 0xd5, 0x3d, 0x80,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00,
};


/* 4E 39 BB F5 4E 39 BB F5 */

/* after unlink */
uint8_t reply_lookup2[] = {
	0xff, 0xff, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x01,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x73,
	0x00, 0x00, 0x81, 0x80, 0x00, 0x00, 0x00, 0x01,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	//0x12, 0xd5, 0x3d, 0x80, 0x12, 0xd5, 0x3d, 0x80,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00,
};

/* create request
 * 00 00 00 01 00 00 00 00
 * 00 00 00 02 00 00 00 00
 * 00 00 00 01 00 00 00 60
 * 00 00 00 11 55 69 6D 45
 * 66 73 41 50 44 55 4C 6F
 * 67 2E 54 78 74 00 00 00
 * 00 00 00 11 00 00 01 80
 * 00 00 00 01 00 00 00 01
 */
uint8_t reply_create[] = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,
	0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
	0x00, 0x00, 0x00, 0x73, 0x00, 0x00, 0x00, 0x01,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x73,
	0x00, 0x00, 0x81, 0x80, 0x00, 0x00, 0x00, 0x01,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	//0x12, 0xd5, 0x3d, 0x80, 0x12, 0xd5, 0x3d, 0x80,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 
};

/* unlink request
 * 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
 * 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00,
 * 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x60,
 * 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
 * 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01,
 * 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x73,
 * 0x00, 0x00, 0x00, 0x11, 0x55, 0x69, 0x6d, 0x45,
 * 0x66, 0x73, 0x41, 0x50, 0x44, 0x55, 0x4c, 0x6f,
 * 0x67, 0x2e, 0x54, 0x78, 0x74, 0x00, 0x00, 0x00,
 * 0x00, 0x00, 0x00, 0x11,
 */

uint8_t reply_generic_success[] = {
	0x00, 0x00, 0x00, 0x00,
};

/* getstat request
 * 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
 * 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00,
 * 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x8f, 0x80,
 * 0x00, 0x00, 0x00, 0x01,
 *
 * reply to request above
 * 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
 * 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x8f, 0x80,
 * 0x00, 0x00, 0x41, 0xed, 0x00, 0x00, 0x00, 0x02,
 * 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 0x08, 0x00,
 * 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 * 0x12, 0xd5, 0x3d, 0x80, 0x12, 0xd5, 0x3d, 0x80,
 * 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 * 0x00, 0x00, 0x00, 0x00, 
 */

uint8_t reply_getstat[] = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x8f, 0x80,
	0x00, 0x00, 0x41, 0xed, 0x00, 0x00, 0x00, 0x02,
	0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 0x08, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	//0x12, 0xd5, 0x3d, 0x80, 0x12, 0xd5, 0x3d, 0x80,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 
};

/* read request
 * 00 00 00 01 00 00 00 00
 * 00 00 00 02 00 00 00 00
 * 00 00 00 01 00 01 8F 82
 * 00 00 00 00 00 00 00 01
 * 00 00 00 02 00 00 00 02
 * 00 00 00 01
 */

uint8_t reply_read[] = {
	0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02,
	0x30, 0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x8f, 0x82,
	0x00, 0x00, 0x81, 0xed, 0x00, 0x00, 0x00, 0x01,
	0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x08, 0x00,
	0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	//0x12, 0xd5, 0x3d, 0x80, 0x12, 0xd5, 0x3d, 0x80,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 
};

/* write request
 * 00 00 00 01 00 00 00 00
 * 00 00 00 02 00 00 00 00
 * 00 00 00 01 00 01 8F 82
 * 00 00 00 00 00 00 00 02
 * 30 32 00 00 00 00 00 02	-> 30 32 -> "02"
 * 00 00 00 01
 *
 * 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x01,
 * 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x5c, 0x32,
 * 0x00, 0x00, 0x81, 0xb6, 0x00, 0x00, 0x00, 0x01,
 * 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x08, 0x00,
 * 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
 * 0x12, 0xd5, 0x3d, 0x80, 0x12, 0xd5, 0x3d, 0x80,
 * 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 * 0x00, 0x00, 0x00, 0x00, 
 */
uint8_t reply_write[] = {
	0x00, 0x00, 0x01, 0x0a, 0x00, 0x00, 0x00, 0x01,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x73,
	0x00, 0x00, 0x81, 0x80, 0x00, 0x00, 0x00, 0x01,
	0x00, 0x00, 0x01, 0x0a, 0x00, 0x00, 0x08, 0x00,
	0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	//0x4e, 0x39, 0xbb, 0xf5, 0x4e, 0x39, 0xbb, 0xf5,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, /*
	0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x8f, 0x82,
	0x00, 0x00, 0x81, 0xed, 0x00, 0x00, 0x00, 0x01,
	0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x08, 0x00,
	0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
	0x12, 0xd5, 0x3d, 0x80, 0x12, 0xd5, 0x3d, 0x80,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, */
};

uint8_t reply_mkdir[] = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,
	0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
	0x00, 0x00, 0x04, 0x20, 0x00, 0x00, 0x00, 0x01,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x20,
	0x00, 0x00, 0x41, 0xc0, 0x00, 0x00, 0x00, 0x02,
	0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x08, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	//0x4e, 0x39, 0xbb, 0xf5, 0x4e, 0x39, 0xbb, 0xf5,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00,
};

unsigned char perso_txt[] = {
    0x01, 0x00, 0x0A, 0x36, 0x34, 0x36, 0x30, 0x37,
    0x36, 0x34, 0x36, 0x30, 0x37, 0x02, 0x00, 0x0A,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x03, 0x00, 0x0F, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x5F, 0x10,
    0x00, 0x10, 0x07, 0x07, 0x00, 0x02, 0x03, 0x09,
    0x0B, 0x0A, 0x31, 0x37, 0x33, 0x37, 0x32, 0x31,
    0x38, 0x32, 0x20, 0x00, 0x10, 0x04, 0x04, 0x04,
    0x0F, 0x08, 0x06, 0x02, 0x04, 0x30, 0x36, 0x33,
    0x38, 0x38, 0x35, 0x34, 0x37, 0x30, 0x00, 0x10,
    0x00, 0x03, 0x0B, 0x00, 0x02, 0x03, 0x01, 0x01,
    0x37, 0x32, 0x38, 0x33, 0x32, 0x31, 0x32, 0x33,
    0x40, 0x00, 0x10, 0x00, 0x00, 0x02, 0x05, 0x0E,
    0x04, 0x00, 0x00, 0x32, 0x34, 0x37, 0x32, 0x36,
    0x33, 0x37, 0x30, 0x50, 0x00, 0x10, 0x06, 0x00,
    0x0A, 0x0F, 0x01, 0x01, 0x01, 0x08, 0x32, 0x35,
    0x32, 0x38, 0x31, 0x32, 0x34, 0x30, 0x05, 0x00,
    0x0A, 0x3E, 0x32, 0x3F, 0x38, 0x3E, 0x34, 0x38,
    0x35, 0x32, 0x34, 0x06, 0x00, 0x5F, 0x10, 0x00,
    0x10, 0x00, 0x0E, 0x0C, 0x0E, 0x07, 0x07, 0x06,
    0x06, 0x31, 0x36, 0x38, 0x36, 0x30, 0x33, 0x37,
    0x31, 0x20, 0x00, 0x10, 0x05, 0x03, 0x01, 0x09,
    0x04, 0x03, 0x06, 0x03, 0x33, 0x34, 0x35, 0x38,
    0x34, 0x33, 0x32, 0x33, 0x30, 0x00, 0x10, 0x08,
    0x04, 0x08, 0x02, 0x06, 0x0B, 0x05, 0x02, 0x38,
    0x30, 0x38, 0x35, 0x30, 0x33, 0x31, 0x32, 0x40,
    0x00, 0x10, 0x04, 0x01, 0x06, 0x05, 0x07, 0x0C,
    0x03, 0x03, 0x34, 0x34, 0x31, 0x31, 0x31, 0x34,
    0x34, 0x37, 0x50, 0x00, 0x10, 0x02, 0x07, 0x03,
    0x00, 0x01, 0x00, 0x05, 0x06, 0x32, 0x30, 0x36,
    0x37, 0x31, 0x35, 0x36, 0x31, 0x07, 0x00, 0x0A,
    0x13, 0x13, 0x11, 0x12, 0x16, 0x33, 0x33, 0x31,
    0x32, 0x36, 0x00, 0x00
};


unsigned char reply_perso1[] = {
	0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x01, 0x0a,
};

unsigned char reply_perso2[] = {
	/*end perso*/
	0x00, 0x00, 0x00, 0x01,
	0x00, 0x00, 0x00, 0x00, /*id*/0x00, 0x01, 0x8f, 0x82,/*id*/
	0x00, 0x00, 0x81, 0xed, 0x00, 0x00, 0x00, 0x01,
	0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x08, 0x00,
	0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	//0x12, 0xd5, 0x3d, 0x80, 0x12, 0xd5, 0x3d, 0x80,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00,
};

#define PERSO	(268 + 8 + 4 + 8 * 6 + 4)

unsigned char reply_perso[PERSO];

static void fs_rapi_dump_request(uint8_t *req, unsigned len, const char *type)
{
	int i;

	return;
/*
	if(len % 4) {
		printk("[dump] len is not multiple of 4. len=%d\n", len);
		return;
	}
*/
	printk("[dump] ---------------- %s ----------------\n", type);
	printk("[dump] ");

	for(i = 0; i < len/*(len / 4)*/; i++) {
		printk("%02x ", req[i] & 0xff);

		if(!((i + 1) % 16))
			printk("\n[dump] ");
	}
	printk("\n[dump] ---------------- %s ----------------\n", type);
}

static int fs_rapi_mount(const char *path)
{
	return 0;
}

static int _fs_rapi_mount(void *msg, unsigned len)
{
	struct rpc_fs_rapi_mount_args *args;
	args = (struct rpc_fs_rapi_mount_args *)msg;

	return fs_rapi_mount(0);
}

struct fs_rapi_vfs {
	char *name;
	uint32_t node_id;
};

static unsigned perso_id = 0;
static unsigned filecount = 0;
uint32_t node_num = 0x60;

#define MAX_VFS_FILES		20
#define MAX_FILENAME_SIZE	64

struct fs_rapi_vfs vfs[MAX_VFS_FILES];

static char *fs_rapi_find_name(uint32_t id)
{
	int i;

	for(i = 0; i < MAX_VFS_FILES; i++) {
		if(!vfs[i].name)
			continue;

		if(vfs[i].node_id == id)
			return vfs[i].name;
	}

	return NULL;
}

static int fs_rapi_lookup(void *msg, unsigned len)
{
	char *file = ((uint8_t *)msg) + 0x1c;
	int i;
	
	pr_info("[FS_RAPI] Lookup file '%s'\n", file);

	for(i = 0; i < MAX_VFS_FILES; i++) {
		if(!vfs[i].name)
			continue;

		if(!strcmp(file, vfs[i].name))
			return vfs[i].node_id;
	}

	return 0;
}

static int fs_rapi_unlink(void *msg, unsigned len)
{
	char *file = ((uint8_t *)msg) + 0x34;
	int i;
	
	pr_info("[FS_RAPI] Unlink file '%s'\n", file);

	if(!filecount)
		return 0;

	for(i = 0; i < MAX_VFS_FILES; i++) {
		if(!vfs[i].name)
			continue;

		if(!strcmp(file, vfs[i].name)) {
			kfree(vfs[i].name);
			vfs[i].name = NULL;

			pr_info("[FS_RAPI] Unlinked file '%s' at pos %d\n", file, i);

			filecount--;
		}
	}

	return 0;
}


static int fs_rapi_create_impl(const char *n)
{
	int i;

	if(filecount >= MAX_VFS_FILES) {
		pr_info("[FS_RAPI] Max VFS file count reached.\n");
		return -ENOMEM;
	}

	for(i = 0; i < MAX_VFS_FILES; i++) {
		if(vfs[i].name)
			continue;

		vfs[i].name = kmalloc(MAX_FILENAME_SIZE, GFP_KERNEL);

		if(!vfs[i].name) {
			pr_info("[FS_RAPI] Failed to create file '%s' at pos %d\n",
				n, i);
			break;
		}

		memset(vfs[i].name, 0, MAX_FILENAME_SIZE);
		memcpy(vfs[i].name, n, strlen(n));
		vfs[i].node_id = ++node_num;
		pr_info("[FS_RAPI] Created file '%s' at pos %d\n", n, i);
		filecount++;

		if(!strcmp(n, "perso.txt"))
			perso_id = vfs[i].node_id;

		return vfs[i].node_id;
	}

	return 0;
}

static int fs_rapi_create(void *msg, unsigned len)
{
	char *file = ((uint8_t *)msg) + 0x1c;
	
	pr_info("[FS_RAPI] Create file '%s'\n", file);

	return fs_rapi_create_impl(file);
}

static int fs_rapi_mkdir(void *msg, unsigned len)
{
	char *file = ((uint8_t *)msg) + 0x1c;
	
	pr_info("[FS_RAPI] Create dir '%s'\n", file);

	return fs_rapi_create_impl(file);
}

static int handle_rpc_call(struct msm_rpc_server *server,
			   struct rpc_request_hdr *req, unsigned len,
			   void **reply, unsigned *reply_len)
{
	void *msg;
	unsigned msg_len;
	int rc;
	uint32_t node = 0, tmp;
	static uint32_t last_opened_node = 0;
	uint8_t *per;

	msg = (void *)(req + 1);
	msg_len = len - sizeof(struct rpc_request_hdr);
	
	printk("[%s] FS_RAPI called, proc=%d [%s] total_len=%d, msg_len=%d\n",
		__func__, req->procedure, rpc_fs_rapi_apis[req->procedure].name,
		len, msg_len);
	
	//fs_rapi_dump_request((uint32_t *)msg, msg_len, 1);

	switch(req->procedure) {
	case RPC_FS_RAPI_MOUNT_PROC:
		_fs_rapi_mount(msg, msg_len);
		*reply_len = sizeof(reply_mount);
		*reply = reply_mount;
		rc = 1;
		break;
		
	case RPC_FS_RAPI_LOOKUP_PROC:
		node = fs_rapi_lookup(msg, msg_len);
		if(node) {
			*reply_len = sizeof(reply_lookup);
			*reply = reply_lookup;
			((uint32_t *)*reply)[6] = cpu_to_be32(node);
			((uint32_t *)*reply)[9] = cpu_to_be32(node);
			last_opened_node = node;
			printk("[FS_RAPI] Sending EXISTS to lookup request.\n");
		} else {
			*reply_len = sizeof(reply_lookup2);
			*reply = reply_lookup2;
			((uint32_t *)*reply)[9] = cpu_to_be32(node_num);
			printk("[FS_RAPI] Sending DOESN'T EXISTS to lookup request.\n");
		}
		rc = 1;
		break;

	case RPC_FS_RAPI_CREATE_PROC:
		node = last_opened_node = fs_rapi_create(msg, msg_len);
		*reply_len = sizeof(reply_create);
		*reply = reply_create;
		((uint32_t *)*reply)[6] = cpu_to_be32(node);
		((uint32_t *)*reply)[9] = cpu_to_be32(node);
		printk("[FS_RAPI] Create file OK, nid = %8x.\n", node);
		rc = 1;
		break;

	case RPC_FS_RAPI_UNLINK_PROC:
		fs_rapi_unlink(msg, msg_len);
		*reply_len = sizeof(reply_generic_success);
		*reply = reply_generic_success;
		rc = 1;
		break;

	case RPC_FS_RAPI_GETSTAT_PROC:
		*reply_len = sizeof(reply_getstat);
		*reply = reply_getstat;
		rc = 1;
		break;

	case RPC_FS_RAPI_READ_PROC:
		fs_rapi_dump_request((uint8_t *)msg, msg_len, "fs_rapi_read_request");
		*reply_len = sizeof(reply_perso);
		*reply = reply_perso;
		printk("[FS_RAPI] READ nid = %8x.\n", be32_to_cpu(((struct fs_rapi_read_req *)msg)->node_id));
		printk("[FS_RAPI] READ prev_id = %08x.\n", be32_to_cpu(((uint32_t *)*reply)[71]));
		((uint32_t *)*reply)[71] = cpu_to_be32(perso_id);
		fs_rapi_dump_request(*reply, *reply_len, "fs_rapi_read_reply");
		rc = 1;
		break;

	case RPC_FS_RAPI_WRITE_PROC:
		//fs_rapi_dump_request((uint8_t *)msg, msg_len, "fs_rapi_write_request");
		tmp = ((uint32_t *)msg)[7];

		if(be32_to_cpu(((struct fs_rapi_write_req *)msg)->node_id) == perso_id) {
			per = reply_perso;
			
			memcpy(per, reply_perso1, sizeof(reply_perso1));
			per += sizeof(reply_perso1);
			
			memcpy(per, ((uint8_t *)msg) + 32, 268);
			per += 268;
			
			memcpy(per, reply_perso2, sizeof(reply_perso2));

			printk("[FS_RAPI] built perso reply\n");
		}
		
		*reply_len = sizeof(reply_write);
		*reply = reply_write;
		((uint32_t *)*reply)[0] = tmp;
		((uint32_t *)*reply)[6] = tmp;
		((uint32_t *)*reply)[3] = cpu_to_be32(last_opened_node);
		printk("[FS_RAPI] WRITE nid=%8x ('%s'), offset=%08x, size=%08x.\n",
			be32_to_cpu(((struct fs_rapi_write_req *)msg)->node_id),
			fs_rapi_find_name(be32_to_cpu(((struct fs_rapi_write_req *)msg)->node_id)),
			be32_to_cpu(((struct fs_rapi_write_req *)msg)->offset),
			be32_to_cpu(((struct fs_rapi_write_req *)msg)->size));
		fs_rapi_dump_request(*reply, *reply_len, "fs_rapi_write_reply");
		rc = 1;
		break;

	case RPC_FS_RAPI_MKDIR_PROC:
		fs_rapi_mkdir(msg, msg_len);
		*reply_len = sizeof(reply_mkdir);
		*reply = reply_mkdir;
		rc = 1;
		break;

	case RPC_FS_RAPI_TRUNCATE_PROC:
		*reply_len = sizeof(reply_generic_success);
		*reply = reply_generic_success;
		rc = 1;
		break;
		
	default:
		printk(KERN_WARNING "[FS_RAPI]: %s unhandled rpc call procedure=%08x\n",
			__func__, req->procedure);
		rc = -ENODEV;
		break;
	}

	//if(*reply)
	//	fs_rapi_dump_request(*reply, *reply_len, 0);
		
	printk("[FS_RAPI] reply_data=%p, reply_len=%d\n", *reply, *reply_len);

	return rc;
}

static struct msm_rpc_server rpc_server = {
	.prog = FS_RAPI_PROG,
	.vers = FS_RAPI_VERS,
	.rpc_call = handle_rpc_call,
};

static int __init rpc_server_init(void)
{
	//fs_rapi_create_impl("UimEfsAPDULog.Txt");
//	perso_id = fs_rapi_create_impl("perso.txt");
	return msm_rpc_create_server(&rpc_server);
}

module_init(rpc_server_init);
